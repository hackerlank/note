如何提高缓存命中率

	介绍
		在memcached中，运行state命令可以查看memcached服务的状态信息，其中cmd_get表示总的get次数，get_hits表示get的总命中次数，命中率 = get_hits/cmd_get。
		同理，在redis中可以运行info命令查看redis服务的状态信息，其中keyspace_hits为总的命中中次数，keyspace_misses为总的miss次数，命中率=keyspace_hits/（keyspace_hits+keyspace_misses）。


	影响缓存命中率的几个因素
		业务场景和业务需求
			缓存适合“读多写少”的业务场景，反之，使用缓存的意义其实并不大，命中率会很低。
			业务需求决定了对时效性的要求，直接影响到缓存的过期时间和更新策略。时效性要求越低，就越适合缓存。在相同key和相同请求数的情况下，缓存时间越长，命中率会越高。
			互联网应用的大多数业务场景下都是很适合使用缓存的。

		缓存的设计（粒度和策略）
			通常情况下，缓存的粒度越小，命中率会越高。举个实际的例子说明：
			当缓存单个对象的时候（例如：单个用户信息），只有当该对象对应的数据发生变化时，我们才需要更新缓存或者让移除缓存。而当缓存一个集合的时候（例如：所有用户数据），其中任何一个对象对应的数据发生变化时，都需要更新或移除缓存。
			还有另一种情况，假设其他地方也需要获取该对象对应的数据时（比如其他地方也需要获取单个用户信息），如果缓存的是单个对象，则可以直接命中缓存，反之，则无法直接命中。这样更加灵活，缓存命中率会更高。
			此外，缓存的更新/过期策略也直接影响到缓存的命中率。当数据发生变化时，直接更新缓存的值会比移除缓存（或者让缓存过期）的命中率更高，当然，系统复杂度也会更高。

		缓存容量和基础设施
			缓存的容量有限，则容易引起缓存失效和被淘汰（目前多数的缓存框架或中间件都采用了LRU算法）。同时，缓存的技术选型也是至关重要的，比如采用应用内置的本地缓存就比较容易出现单机瓶颈，而采用分布式缓存则毕竟容易扩展。所以需要做好系统容量规划，并考虑是否可扩展。此外，不同的缓存框架或中间件，其效率和稳定性也是存在差异的。

		其他因素
			当缓存节点发生故障时，需要避免缓存失效并最大程度降低影响，这种特殊情况也是架构师需要考虑的。业内比较典型的做法就是通过一致性Hash算法，或者通过节点冗余的方式。

			有些朋友可能会有这样的理解误区：既然业务需求对数据时效性要求很高，而缓存时间又会影响到缓存命中率，那么系统就别使用缓存了。其实这忽略了一个重要因素--并发。通常来讲，在相同缓存时间和key的情况下，并发越高，缓存的收益会越高，即便缓存时间很短。

	提高缓存命中率的方法
		从架构师的角度，需要应用尽可能的通过缓存直接获取数据，并避免缓存失效。这也是比较考验架构师能力的，需要在业务需求，缓存粒度，缓存策略，技术选型等各个方面去通盘考虑并做权衡。尽可能的聚焦在高频访问且时效性要求不高的热点业务上，通过缓存预加载（预热）、增加存储容量、调整缓存粒度、更新缓存等手段来提高命中率。
		对于时效性很高（或缓存空间有限），内容跨度很大（或访问很随机），并且访问量不高的应用来说缓存命中率可能长期很低，可能预热后的缓存还没来得被访问就已经过期了。


缓存在高并发场景下的常见问题

	缓存一致性问题
	当数据时效性要求很高时，需要保证缓存中的数据与数据库中的保持一致，而且需要保证缓存节点和副本中的数据也保持一致，不能出现差异现象。这就比较依赖缓存的过期和更新策略。一般会在数据发生更改的时，主动更新缓存中的数据或者移除对应的缓存。

		更新数据库成功	->  更新缓存失败		->		数据不一致
		更新缓存成功		->  更新数据库失败 	->		数据不一致
		更新数据库成功 	->  淘汰缓存失败 		-> 		数据不一致
		淘汰缓存成功 		-> 	更新数据库失败 	-> 		查询缓存 miss

	缓存并发问题
	缓存过期后将尝试从后端数据库获取数据，这是一个看似合理的流程。但是，在高并发场景下，有可能多个请求并发的去从数据库获取数据，对后端数据库造成极大的冲击，甚至导致 “雪崩”现象。此外，当某个缓存key在被更新时，同时也可能被大量请求在获取，这也会导致一致性的问题。那如何避免类似问题呢？我们会想到类似“锁”的机制，在缓存更新或者过期的情况下，先尝试获取到锁，当更新或者从数据库获取完成后再释放锁，其他的请求只需要牺牲一定的等待时间，即可直接从缓存中继续获取数据。





reids 命中率不高
	性能测试中遇到的问题，总结如下。
	1、 问题
		测试某接口时发现redis中的keyspace_misses一直在增加，即未命中数一直增加。
	2、解决分析过程
		1） 使用dbsize命令查出来的keys数大于keys *|wc –l统计出来的数，说明有过期的key存在。
		2） 执行flashall清除全部数据。
		3） 重新生成一批新数据。
		4） 使用dbsize命令查出来的keys数等于keys *|wc –l统计出来的数。
		5） 测试时监控未命中数，此值未再有所改变，命中率为100%。
	3、总结
		当有过期的key存在时，会导致命中率不是100%，首先可以使用dbsize命令查一下keys数，再用keys *|wc –l统计一下keys数，若不相等就说明有过期的keys存在。